package controleur;

import java.util.*;

import controleur.strategie.Strategie;
import controleur.strategie.StrategieA;
import modele.Arbitre;
import modele.Variante;
import modele.cartes.Carte;
import modele.cartes.Pioche;
import modele.cartes.Tas;
import modele.cartes.Trophee;
import modele.joueurs.Joueur;
import modele.joueurs.JoueurReel;
import modele.joueurs.JoueurVirtuel;

/**
 * Classe qui représente la partie de Jest
 */
public class Partie {
	/**
	 * attribut privé static de type partie qui représente l'unique partie pouvant
	 * être lancée (implémentation singleton)
	 */
	private static Partie partie = null;
	/**
	 * attribut privé de type Arraylist qui représente la liste des joueurs de la
	 * partie
	 */
	private ArrayList<Joueur> joueurs;
	/**
	 * attribut privé de type entier qui représente le nombre de joueurs de la
	 * partie
	 */
	private int nbJoueur;
	/**
	 * attribut privé de type entier représentant le nombre de joueurs virtuels de
	 * la partie
	 */
	private int nbJoueurVirtuel;
	/**
	 * attribut privé de type entier qui représente le numéro du tour de jeu de la
	 * partie
	 */
	private int tourDeJeu;
	/**
	 * attribut privé de type Tas qui représente le tas de la partie
	 */
	private Tas tas;
	/**
	 * attribut privé de type Pioche qui représente la pioche de la partie
	 */
	private Pioche pioche;
	/**
	 * attribut privé de type StrategieA qui représente la stratégie utilisée par
	 * les joueurs virtuels
	 */
	private Strategie strategie;
	/**
	 * attribut privé de type Trophee qui représente le premier trophée de la partie
	 */
	private Trophee trophee1;
	/**
	 * attribut privé de type Trophee qui représente le deuxième trophée de la
	 * partie si le nombre de joueurs nécessitent deux trophées
	 */
	private Trophee trophee2;
	/**
	 * attribut privé de type booléen qui définit si l'extension est activée
	 */
	private boolean extension;
	/**
	 * attribut privé de type Variante qui définit quelle variante est utilisée dans
	 * la partie
	 */
	private Variante variante;

	/**
	 * constructeur de la partie (en privé pour l'implémentation du singleton)
	 */
	private Partie() {
		this.joueurs = new ArrayList<Joueur>();
		this.nbJoueur = 3;
		this.nbJoueurVirtuel = 1;
		this.tourDeJeu = 1;
		this.tas = new Tas();
		this.pioche = new Pioche();
		this.strategie = new StrategieA();
		this.trophee1 = null;
		this.trophee2 = null;
		this.variante = Variante.BASE;
		this.extension = false;
	}

	/**
	 * méthode qui créer la partie afin de garder l'unicité de la partie
	 * 
	 * @return la partie en cours
	 */
	public static Partie getInstance() {
		if (partie == null) {
			partie = new Partie();
		}
		return partie;
	}

	/**
	 * méthode qui ajoute un joueur aux joueurs de la partie
	 * 
	 * @param joueur le joueur ajouté
	 */
	public void addJoueur(Joueur joueur) {
		this.joueurs.add(joueur);
	}

	/**
	 * getter qui retourne la liste des joueurs de la partie
	 * 
	 * @return la liste des joueurs
	 */
	public ArrayList<Joueur> getJoueurs() {
		return this.joueurs;
	}

	/**
	 * setter qui modifie,le booléen responsable de l'extension
	 * 
	 * @param b le booléen modifiant la présence ou non de l'extension
	 */
	public void setExtension(boolean b) {
		this.extension = b;
	}

	/**
	 * getter qui retourne si l'extension est active
	 * 
	 * @return le booléen qui définit si l'extension est active ou non
	 */
	public boolean getExtension() {
		return this.extension;
	}

	/**
	 * setter qui permet de modifier la variante de la partie
	 * 
	 * @param v la variante à implémenter dans la partie
	 */
	public void setVariante(Variante v) {
		this.variante = v;
	}

	/**
	 * getter qui retourne la variante de la partie
	 * 
	 * @return la variante utilisée
	 */
	public Variante getVariante() {
		return this.variante;
	}

	/**
	 * méthode qui configure le nombre de joueur
	 * 
	 * @param sc paramètre qui nous permet de rentrer les valeurs dans la console
	 */
	public void configurerNbJoueur(Scanner sc) {
		System.out.println("\n Combien de joueurs souhaitez vous (entre 3 et 4)?\n ");

		String choix = "0";
		boolean valide = false;
		while (valide == false) {

			choix = sc.nextLine();

			switch (choix) {
			case "3":
				this.nbJoueur = 3;
				valide = true;
				break;
			case "4":
				this.nbJoueur = 4;
				valide = true;

				break;
			default:
				System.out.println("Vous avez tapé un mauvais nombre, veuillez recommencer");

			}
		}

	}

	/**
	 * méthode qui permet de configurer le nombre de joueurs virtuels
	 * 
	 * @param sc paramètre qui nous permet de rentrer les valeurs dans la console
	 */
	public void configurerNbJoueurVirtuel(Scanner sc) {
		System.out.println("\n Combien de joueurs virtuels souhaitez vous (inférieur à " + this.nbJoueur + ")?");

		String choix = "0";
		boolean valide = false;
		while (valide == false) {

			choix = sc.nextLine();

			switch (choix) {
			case "0":
				this.nbJoueurVirtuel = 0;
				valide = true;
				break;
			case "1":
				this.nbJoueurVirtuel = 1;
				valide = true;
				break;
			case "2":
				this.nbJoueurVirtuel = 2;
				valide = true;
				break;
			case "3":
				if (this.nbJoueur == 4) {
					this.nbJoueurVirtuel = 3;
					valide = true;
					break;
				} else {
					System.out.println("Vous avez tapé un mauvais nombre, veuillez recommencer");

				}
			default:
				System.out.println("Vous avez tapé un mauvais nombre, veuillez recommencer");

			}
		}

	}

	/**
	 * méthode qui permet de configurer la partie
	 * 
	 * @param sc paramètre qui nous permet de rentrer les valeurs dans la console
	 */
	public void configurerPartie(Scanner sc) {
		System.out.println("------Jeu De Jest------ \n");
		System.out.println("Que souhaitez vous faire? \n 1. Lancer une partie \n 2. Gérer les paramètres \n");
		String choix1 = "0";
		boolean valide = false;
		while (valide == false) {

			choix1 = sc.nextLine();

			switch (choix1) {
			case "1":
				valide = true;
				break;
			case "2":
				partie.configurerNbJoueur(sc);
				partie.configurerNbJoueurVirtuel(sc);
				partie.configurationExtension(sc);
				partie.configurationVariantes(sc);
				valide = true;

				break;
			default:
				System.out.println("Vous avez tapé un mauvais nombre, veuillez recommencer");

			}
		}

	}

	/**
	 * méthode qui permet de configurer l'extension choisie
	 * 
	 * @param sc paramètre qui nous permet de rentrer les valeurs dans la console
	 */
	public void configurationExtension(Scanner sc) {
		char reponse;
		System.out.println("Souhaitez-vous jouer avec l'extension de carte ? 1- Oui, 2- Non\n"
				+ "Rappel: l'extension contient les cartes:");
		reponse = sc.nextLine().charAt(0);
		while (reponse != '1' && reponse != '2') {
			System.out.println("Vous avez tapé un mauvais nombre, veuillez recommencer");
			reponse = sc.nextLine().charAt(0);
		}
		if (reponse == '1') {
			this.setExtension(true);
		}
	}

	/**
	 * méthode qui permet de configurer la variante choisie
	 * 
	 * @param sc paramètre qui nous permet de rentrer les valeurs dans la console
	 */
	public void configurationVariantes(Scanner sc) {
		char reponse;
		System.out
				.println("Avec quelles règles souhaitez-vous jouer ? 0- Règles de base, 1- Variante 1, 2- Variante 2\n"
						+ "Rappel: \n"
						+ "Variante 1: A la fin de la partie, vous échanger votre Jest avec le joueur suivant\n"
						+ "Variante 2: Essayez de collecter toutes les cartes de même valeur. Si vous réussissez à obtenir tous les 2 ou 3 votre score sera multiplié par cette valeur"); // Pas
																																															// avec
																																															// les
																																															// 4
																																															// car
																																															// ce
																																															// serait
																																															// trop
																																															// cheaté
		reponse = sc.nextLine().charAt(0);
		while (reponse != '0' && reponse != '1' && reponse != '2') {
			System.out.println("Vous avez tapé un mauvais nombre, veuillez recommencer");
			reponse = sc.nextLine().charAt(0);
		}
		if (reponse == '1') {
			this.setVariante(Variante.ECHANGE);
		}
		if (reponse == '2') {
			this.setVariante(Variante.COMPTAGE);
		}
	}

	/**
	 * méthode qui initialise la partie en créant les joueurs avec leurs pseudo,
	 * choisit les trophées et mélange la pioche
	 * 
	 * @param sc paramètre qui nous permet de rentrer les valeurs dans la console
	 */
	public void initialisationPartie(Scanner sc) {

		int i;
		String pseudo = "0";
		for (i = 0; i < (nbJoueur - nbJoueurVirtuel); i++) {
			System.out.println("Choisir un pseudo pour le joueur" + (i + 1));
			pseudo = sc.nextLine();
			new JoueurReel(pseudo, this);
		}
		while (i < nbJoueur) {
			new JoueurVirtuel(this);
			i++;
		}
		if (this.getExtension() == true) {
			this.getPioche().ajoutExtension(this);
		}
		this.pioche.melanger();
		this.trophee1 = new Trophee(this.pioche.retirerCarteDuHaut());
		this.trophee1.conditionTrophee();
		System.out.println("Trophée 1: " + this.trophee1);
		if (nbJoueur == 3) {
			this.trophee2 = new Trophee(this.pioche.retirerCarteDuHaut());
			this.trophee2.conditionTrophee();
			System.out.println("Trophée 2: " + this.trophee2);
		}
		System.out.println("\n");

	}

	/**
	 * méthode qui fait piocher chaque joueur et leurs fait créer leur offre
	 * 
	 * @param sc paramètre qui nous permet de rentrer les valeurs dans la console
	 */
	public void creationDesOffres(Scanner sc) {
		for (Joueur j : joueurs) {
			if (partie.tourDeJeu == 1) {
				j.piocherDansPioche(partie.pioche);
				j.piocherDansPioche(partie.pioche);
			} else {
				j.piocherDansTas(partie.tas);
				j.piocherDansTas(partie.tas);
			}

		}
		for (Joueur j : joueurs) {
			if (j instanceof JoueurVirtuel) {
				j = (JoueurVirtuel)j;
				j.faireOffre(partie.strategie);
			} else {
				int i = 1;
				for (Carte c : j.getMain().getOffre()) {
					System.out.println("Carte " + i + ": " + c);
					i++;
				}

				System.out.println(j.getPseudo()
						+ ": Quel carte voulez vous rendre face cachée?\n 1.Première Carte \n 2.Deuxième Carte");
				String choix = "0";
				boolean valide = false;
				while (valide == false) {

					choix = sc.nextLine();

					switch (choix) {
					case "1":
						j.faireOffre(false);

						valide = true;
						break;
					case "2":
						j.faireOffre(true);
						valide = true;

						break;
					default:
						System.out.println("Vous avez tapé un mauvais nombre, veuillez recommencer");

					}
				}
			}
		}
	}

	/**
	 * méthode qui affiche les offres de tous les joueurs
	 */
	public void affichageDesOffres() {
		int i = 1;

		for (Joueur j : joueurs) {
			System.out.println("Joueur" + i + " " + j.getPseudo() + ":");
			i++;
			j.getMain().afficherOffre();
		}
	}

	/**
	 * méthode qui compare chaque carte visible afin de déterminer la meilleure et
	 * donc de définir le joueur qui commence
	 * 
	 * @return le joueur qui commence
	 */
	public Joueur testMeilleureCarteVisible() {

		Joueur piocheur = null;
		for (Joueur j2 : joueurs) {
			if (j2.getJouabilite() == true) {
				piocheur = j2;
			}
		}
		for (Joueur j : joueurs) {
			if (j.getJouabilite() == true) {
				if (j.getMain().getOffre().get(0).getVisibilite() == true
						&& piocheur.getMain().getOffre().get(0).getVisibilite() == true) {
					if (j.getMain().getOffre().get(0).cartePlusHaute(piocheur.getMain().getOffre().get(0))) {
						piocheur = j;
					}

				} else if (j.getMain().getOffre().get(0).getVisibilite() == true
						&& piocheur.getMain().getOffre().get(1).getVisibilite() == true) {
					if (j.getMain().getOffre().get(0).cartePlusHaute(piocheur.getMain().getOffre().get(1))) {
						piocheur = j;
					}
				} else if (j.getMain().getOffre().get(1).getVisibilite() == true
						&& piocheur.getMain().getOffre().get(1).getVisibilite() == true) {
					if (j.getMain().getOffre().get(1).cartePlusHaute(piocheur.getMain().getOffre().get(1))) {
						piocheur = j;
					}
				} else {
					if (j.getMain().getOffre().get(1).cartePlusHaute(piocheur.getMain().getOffre().get(0))) {
						piocheur = j;
					}

				}
			}

		}
		return piocheur;
	}

	/**
	 * méthode qui permet à tous les joeurs de piocher dans les offres adverses
	 * 
	 * @param sc paramètre qui nous permet de rentrer les valeurs dans la console
	 */
	public void piochageDesOffres(Scanner sc) {
		System.out.println("On pioche !");
		Joueur piocheur = partie.testMeilleureCarteVisible();
		for (Joueur j1 : joueurs) {
			for (Joueur j : joueurs) {
				if (j == piocheur) {
					System.out.println("\n C'est au tour de: " + j.getPseudo());
					if (j instanceof JoueurVirtuel) {
						Joueur joueurAPiocher = j.choisirJoueurAPiocher(partie.strategie, partie.joueurs);
						for (Joueur j3 : joueurs) {
							if (j3 == joueurAPiocher) {
								j.piocherOffre(partie.strategie, j3);
							}
						}
						System.out.println(j.getPseudo() + " prend la carte de " + joueurAPiocher.getPseudo());
						if (joueurAPiocher.getJouabilite() == true) {
							piocheur = joueurAPiocher;
						} else {
							piocheur = partie.testMeilleureCarteVisible();
						}

					} else {
						int n = 1;

						for (Joueur joueurAafficher : joueurs) {
							System.out.println(joueurAafficher.getPseudo() + ": numéro " + n + ", piochabilité: "
									+ joueurAafficher.getMain().getPiochabilite());
							n++;
						}
						System.out.println("\n");
						System.out.println(
								j.getPseudo() + ", chez quel joueur voulez vous piocher ? (indiquez son numéro)\n");
						char choix = '0';

						// Choix de la carte qu'on veut prendre et ajouter à son jest
						choix = sc.nextLine().charAt(0);

						// On vérifie qu'on peut bien piocher dans l'offre de ce joueur
						while (testChoixValide(choix, j) == false) {
							n = 1;
							for (Joueur joueurAafficher : joueurs) {
								System.out.println(joueurAafficher.getPseudo() + ": numéro " + n + ", piochabilité: "
										+ joueurAafficher.getMain().getPiochabilite());
								n++;
							}
							choix = sc.nextLine().charAt(0);
						}

						Joueur j2 = joueurs.get(Character.getNumericValue(choix) - 1);
						System.out.println("Et quelle carte de " + j2.getPseudo()
								+ " souhaitez-vous prendre ? Visible: V, Cachée: C   ");
						boolean carteVisible = false;
						char carteAPiocher = sc.nextLine().charAt(0);
						while (carteAPiocher != 'c' && carteAPiocher != 'C' && carteAPiocher != 'v'
								&& carteAPiocher != 'V') {
							System.out.println("Vous avez tapé un mauvais caratère, veuillez recommencer");
							carteAPiocher = sc.nextLine().charAt(0);
						}
						if (carteAPiocher == 'V' || carteAPiocher == 'v') {
							carteVisible = true;
						}
						System.out.println("Vous prenez la carte de " + j2.getPseudo() + ", qui est : ");
						Carte cartePiochee = j.piocherOffre(j2, carteVisible);
						System.out.println(cartePiochee);
						if (j2.getJouabilite() == true) {
							piocheur = j2;
						} else {
							piocheur = partie.testMeilleureCarteVisible();
						}
					}

				}
			}
			System.out.println("\n");
		}
		for (Joueur j : joueurs) {
			j.setJouabilite(true);
			j.getMain().setPiochabilite(true);
		}
	}

	/**
	 * getter qui retourne la pioche de la partie
	 * 
	 * @return la pioche de la partie
	 */
	public Pioche getPioche() {
		return this.pioche;
	}

	/**
	 * méthode qui détermine le choix de piochage est valide ou non
	 * 
	 * @param choix le choix rentré par le joueur actuel
	 * @param j le joueur qui choisit
	 * @return le booléen représentant la validité du choix
	 */
	public boolean testChoixValide(char choix, Joueur j) {
		boolean valide = false;
		if (choix == '1' || choix == '2' || choix == '3' || choix == '4') {

			int choixEntier = Character.getNumericValue(choix) - 1;

			if (choixEntier < partie.joueurs.size()
					&& partie.joueurs.get(choixEntier).getMain().getPiochabilite() == true) {

				boolean dernierJoueur = true;
				for (Joueur testJoueur : partie.joueurs) {
					if (testJoueur.getMain().getPiochabilite() == true && testJoueur != j) {
						dernierJoueur = false;
					}
				}
				if (choixEntier != partie.joueurs.indexOf(j)
						|| (choixEntier == partie.joueurs.indexOf(j) && dernierJoueur == true)) {

					valide = true;
				} else {
					System.out.println(
							"Vous ne pouvez pas piocher votre propre offre si vous n'êtes pas le dernier joueur");
				}
			} else {
				System.out.println("Malheureusement, ce joueur n'est pas piochable");
			}
		} else {
			System.out.println("Veuillez saisir un chiffre valide");
		}
		return valide;
	}
	/**
	 * méthode qui permet de récupérer pour chaque joueur sa dernière carte 
	 * lorsque la partie est finie
	 */
	public void recupererDerniereCarte() {
		for (Joueur joueur : joueurs) {
			if (joueur.getMain().getOffre().get(0) != null) {
				joueur.getJest().getCartes().add(joueur.getMain().getOffre().get(0));
				joueur.getMain().getOffre().remove(0);
			} else if (joueur.getMain().getOffre().get(1) != null) {
				joueur.getJest().getCartes().add(joueur.getMain().getOffre().get(1));
				joueur.getMain().getOffre().remove(1);
			}
		}
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		Arbitre arbitre = new Arbitre();
		Partie.getInstance();
		ArrayList<Joueur> classement = new ArrayList<Joueur>();
		partie.configurerPartie(sc);
		partie.initialisationPartie(sc);
		while (partie.getPioche().getA0Carte(partie) == false) {
			if (partie.tourDeJeu > 1) {
				System.out.println("Tour de jeu : " + partie.tourDeJeu);
			}
			System.out.println("Taille de la pioche: " + partie.getPioche().getPioche().size() + "\n");
			partie.creationDesOffres(sc);
			System.out.println("\n");
			partie.affichageDesOffres();
			System.out.println("\n");
			partie.piochageDesOffres(sc);
			System.out.println("\n");
			partie.tourDeJeu++;
			partie.tas.nouveauTas(partie);
		}

		System.out.println("La pioche n'a plus de cartes");

		System.out.println("Vous récupérez votre dernière carte");

		partie.recupererDerniereCarte();

		partie.trophee1.conditionTrophee();
		partie.trophee2.conditionTrophee();

		arbitre.attribuerTrophee(partie.joueurs, partie.trophee1, partie.trophee2, partie.getVariante());

		if (partie.getVariante() == Variante.ECHANGE) {
			arbitre.echangeJest(partie);
		}

		System.out.println("Affichons les jest des joueurs");
		for (Joueur joueur : partie.getJoueurs()) {
			System.out.println(joueur.getPseudo() + " : ");
			joueur.getJest().afficherJest();
		}

		classement = arbitre.etablirClassement(partie);
		System.out.println("Classement: ");
		for (Joueur j : classement) {
			System.out.println(j.getPseudo() + " : " + j.getScore() + " points \n");
		}
		System.out.println("Le gagnant est donc " + classement.get(classement.size() - 1).getPseudo()
				+ " avec un score de " + classement.get(classement.size() - 1).getScore());

		sc.close();

	}

}
